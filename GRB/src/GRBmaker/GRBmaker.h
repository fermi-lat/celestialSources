// File: GRBmaker.h
//
// GRB simulation

// Interface:
// This class is instantiated in three ways:
// -  No input
//       In this mode, it generates nbsim number of bursts and for each burst, it creates and records a photon list (time,energy)
//		 The number nbsim is generated by the GRBobsConstants class.
// -  Input: Filename
//		 In this mode, it will read the photon list (time,energy) generated by the first option
// -  Input: duration, flux, fraction, power law index, npulse, flag
//		 In this mode, it creates a photon list for the burst specified by the input parameters and if the flag is set,
//			records it in a file
//
#ifndef GRB_MAKER_H
#define GRB_MAKER_H

#include "GRBobsUtilities.h"
#include <vector>
#include <string>
#include <functional>  // for unary_function and plus
#include <fstream>


class HepRandomEngine;
class TimeEnergy;


class GRBmaker
{
	friend class GRBobsSpectrum;  // to give it access to the private members
	friend std::ifstream &operator >> (std::ifstream &is, GRBmaker &grbMaker);
  
 public:
	 // Constructors
	 // generate GRBobsConstants::nbsim bursts and create photon list for each burst
	 GRBmaker();			

	 // read burst information and photon list from the specified file
	 GRBmaker(const std::string &filename);

	//	create photon list from the burst information specified by the input parameters and record it in a file if flag is set
 	 GRBmaker(double duration, int npuls, double flux, double fraction, double powerLawIndex, bool flag);

	  
	 // No memory management function required
	 // So - need for destructor, copy constructor and assignment operator to be defined


	 // Accessor functions
	 double univFWHM() const { return m_univFWHM; }

     double duration() const { return m_duration; }

	 double specnorm() const { return m_specnorm; }

	 std::pair<float,float> dir() const { return m_grbdir; }

	 double flux() const { return m_flux; }

	 float fraction() const { return m_fraction; };

	 float powerLawIndex() const { return m_powerLawIndex; }

	 int npuls() const { return m_npuls; }

	 int nphoton() const { return m_nphoton; } 

	 const std::vector<TimeEnergy> &photonlist() const  { return m_photonlist; }




 
 private:
	 // private accessor functions
	 std::vector<TimeEnergy> &photonlist()  { return m_photonlist; }


	 // class methods
	 // create base string used to generate output file name
	 std::string baseFilename() const;

	 // use base name generated by baseFilename to create the output file name
	 std::string outputFilename(const std::string &base, const long isim) const;

	 // return a copy of itself
	 GRBmaker *clone() const;

	 // use interpolation to compute the flux for the burst
	 double computeFlux(HepRandomEngine *engine, const long diff, const long minval, const std::vector<long> &in,
		 const std::vector<double> &v) const;

	 // compute the direction of the burst
	 std::pair<float,float> direction(HepRandomEngine *engine) const;

	 // use interpolation to return the computed value to the caller (duration/power law index)
	 double evaluate(HepRandomEngine *engine, const long diff, const long minval, const std::vector<long> &in, 
		 const std::vector<double> &v) const;

	 // Choose durations from the BATSE bimodal duration distribution, where the measurement process is described by 
	 //		Bonnell et al. (1997, ApJ, 490, 79).  The parent sample is same as for peak fluxes: from GRB 910421 (trig #105)
	 //		to GRB 990123 (trig #7343).  This partial sample (1262) includes bursts where backgrounds could be fitted, and
	 //		peak fluxes subsequently measured.  The sample spans 7.75 years.
	 void getDuration(HepRandomEngine *engine, long &nlong, std::vector<double> &duration) const;

	 // Choose peak fluxes from the BATSE log N - log P;  see Bonnell et al. 1997, ApJ, 490, 79, which durplicates the procedure
	 //		specified by Pendleton*.  The measurement procedure is applied uniformly for that part of the BATSE sample from
	 //		GRB 910421 (trig #105) to GRB 990123 (trig #7343).  
	 //		(*Pendleton used a different PF estimation technique for the initial BATSE Catalog).
	 void getFlux(HepRandomEngine *engine, long nlong, std::vector<double> &flux, std::vector<double> &fraction) const;

	 // Choose spectral power-law indices from the BATSE power-law distribution, as measured by Preece et al. (1999)
	 void getPowerLawIndex(HepRandomEngine *engine, std::vector<double> &powerLawIndex) const;

	 // use pulse data to compute the time profiles
	 void getTimes(HepRandomEngine *engine, const long nphots, const long deltbinsleft, const long iphotoff, 
		 const double tmax, const std::vector<double> &pulse);

	 // return samples from global distributions for GRBs: duraton, peak fluxes, and power law indices
	 void grbGlobal(HepRandomEngine *engine, std::vector<double> &duration, std::vector<double> &flux, 
		 std::vector<double> &fraction, std::vector<double> &powerLawIndex);

	 // returns the index i to the last element of "in" vector such that in[i] < some random value
	 long index(HepRandomEngine *engine, const long diff, const long minval, const std::vector<long> &in) const;

	 // Computes photon energies for the current burst
	 void makeEnergies(HepRandomEngine *engine);

	 // Compute number of photons for the current burst:
	 //		SpecNorm units, integrated Peak Flux: photons cm^-2 s^-1 (>grbcst::ethres).
	 //		Researches on normalization:
	 //			(1) Bonnell's fits to bright BATSE bursts.
	 //			(2)	comparison with EGRET norms for bright bursts - Catelli's, Dingus' and Schneid's works.
	 //			(3) analysis of Preece et al. spectroscopy catalog of bright BATSE bursts (see JPN routine Specanal.pro).
	 //
	 //		The cofactors for SpecNorm are:
	 //			(a) {average flux/peak flux} = ~1/7.
	 //			(b)	scaling by (peak_flux)^1.5, determined from inspection of Preece et al..
	 //			(c)	duration (seconds).
	 //			(d)	282743 cm^2 (6-meter dia. illuminated disk).
	 //			(e)	scaling to integral above Ethres (e.g., 0.03 GeV) for case beta=-2.
	 //			(f)	dispersion (dynrange) to approximately replicate the scatter in peak flux vs. normalization at 1 MeV
	 //					as estimated from Preece et al. catalog.
	 //			(g)	a dependence on power-law index as estimated from Preece et al. catalog.
	 //
	 //		Thus, m_nphoton is number of photons normally incident on projected disk of GLAST illumination sphere, integrated
	 //			above Ethres, for chosen peak flux and duration.  Energies distributed as power-law index.

	 void makeGRB(HepRandomEngine *engine);

	 // Makes BATSE-like GRB time profiles, placing GLAST photons a la cumulative BATSE intensity, but in narrower pulses:
	 //		(1) m_npuls = number of pulses, proportional to BATSE duration.
	 //		(2) pulse peak amplitude is random (0.0=>1.0); sort amps in descending amp order.
	 //		(3)	scramble amps of {1st,2nd} halves of pulses, separately (leaves profile assymmetric).
	 //		(4)	center of pulse time is random within duration.  sort the times in ascending order.
	 //		(5)	pulse width is drawn from BATSE width distribution for bright bursts (attributes paper), scaled to GLAST energies.
	 //				using width ~E^-0.333.
	 //		(6)	make m_npuls pulses with "bisigma" shapes => sum to produce time profile
	 //		(7)	form cumulative distribution of BATSE intensity
	 //		(8) distribute the m_nphoton photons according to cumulative intensity => GRBtimes
	 //		(9)	offset the photon times according to (a) energy dependence, width ~E^-0.333 and (b) time of peak, also 
	 //				proportional to E^-0.333.
	 void makeTimes(HepRandomEngine *engine);

	 // Returns number of photons in the current burst
	 long nphoton(double duration);

	 // Computes spectral normalization
	 double specnorm(HepRandomEngine *engine, double fraction, double powerLawIndex);




	 // data members
	 double                   m_univFWHM;
	 double                   m_duration;
	 std::pair<float,float>   m_grbdir;
	 double                   m_flux;
	 double                   m_fraction;
 	 double                   m_powerLawIndex;
	 double                   m_specnorm;
	 int                      m_npuls;

	 long                     m_nphoton;
	 std::vector<TimeEnergy>  m_photonlist;
};
	 


class TimeEnergy
{
 public:
	TimeEnergy() { };

    inline void setTime(double time)   {m_time=time;}
    inline void setEnergy(double energy) {m_energy=energy;}
 
    inline double time()   {return m_time;}
    inline double energy() {return m_energy;}

 private:
    double m_time;
    double m_energy;
};



class timeCmp
{
 public:
    //  bool operator()(const DataOut& data1,const DataOut& data2)
    bool operator()(TimeEnergy &data1, TimeEnergy &data2)
	{
	   return data1.time() < data2.time();    
	}
};


// Output operator
std::ofstream &operator<<(std::ofstream &os, const GRBmaker &grbMaker);

#endif // GRB_MAKER_H
