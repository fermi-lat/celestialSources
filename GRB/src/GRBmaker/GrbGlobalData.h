// File: GrbGlobalData.h
//
// GRB simulation

// Interface:
// This class is instantiated in three ways:
// -  No input
//       In this mode, it generates nbsim number of bursts and for each burst, it creates and records a photon list (time,energy)
//		 The number nbsim is generated by the GRBobsConstants class.
// -  Input: Filename
//		 In this mode, it will read the photon list (time,energy) generated by the first option
// -  Input: duration, flux, fraction, power law index, npulse, flag
//		 In this mode, it creates a photon list for the burst specified by the input parameters and if the flag is set,
//			records it in a file
//
#ifndef GRB_GLOBAL_DATA_H
#define GRB_GLOBAL_DATA_H

#include <vector>
#include <string>
#include <functional>  // for unary_function


class HepRandomEngine;


class GrbGlobalData
{
public:
    // static access/destruction
    static GrbGlobalData	*instance(HepRandomEngine *engine);
    static void            kill ();
    
    
    
    // Accessor functions
    const std::vector<double> duration() const      { return m_duration; }
    const std::vector<double> flux() const          { return m_flux; }
    const std::vector<double> fraction() const      { return m_fraction; };
    const std::vector<double> alpha() const		 { return m_alpha; }
    const std::vector<double> beta() const			 { return m_beta; }
    const std::vector<double> epeak() const		 { return m_epeak; }
    
    
protected:
    // Singleton - protect ctor/dtor
    GrbGlobalData(HepRandomEngine *engine);
    virtual ~GrbGlobalData();
    
    
private:
private:
    static GrbGlobalData* s_instance;
    
    // Class methods
    
    // Use interpolation to compute the flux for the burst
    double computeFlux(HepRandomEngine *engine, const long diff, const long minval, const std::vector<long> &in,
        const std::vector<double> &v) const;
    
    // Use interpolation to return the computed value to the caller (duration/power law index)
    double evaluate(HepRandomEngine *engine, const long diff, const long minval, const std::vector<long> &in, 
        const std::vector<double> &v) const;
    
    // Return samples from global distributions for GRBs: duraton, peak fluxes, and power law indices
    void grbGlobal(HepRandomEngine *engine);
    
    // Returns the index i to the last element of "in" vector such that in[i] < some random value
    long index(HepRandomEngine *engine, const long diff, const long minval, const std::vector<long> &in) const;
    
    // Choose durations from the BATSE bimodal duration distribution, where the measurement process is described by 
    //		Bonnell et al. (1997, ApJ, 490, 79).  The parent sample is same as for peak fluxes: from GRB 910421 (trig #105)
    //		to GRB 990123 (trig #7343).  This partial sample (1262) includes bursts where backgrounds could be fitted, and
    //		peak fluxes subsequently measured.  The sample spans 7.75 years.
    void getDuration(HepRandomEngine *engine, long &nlong);
    
    // Choose peak fluxes from the BATSE log N - log P;  see Bonnell et al. 1997, ApJ, 490, 79, which durplicates the procedure
    //		specified by Pendleton*.  The measurement procedure is applied uniformly for that part of the BATSE sample from
    //		GRB 910421 (trig #105) to GRB 990123 (trig #7343).  
    //		(*Pendleton used a different PF estimation technique for the initial BATSE Catalog).
    void getFlux(HepRandomEngine *engine, long nlong);
    
    // Choose spectral power-law indices from the BATSE power-law distribution, as measured by Preece et al. (1999)
    void getPowerLawIndex(HepRandomEngine *engine);
    
    void powerLawIndex(HepRandomEngine *engine, const std::vector<int> &histpl, const std::vector<double> &loEdges, 
    	 const double factor, std::vector<double> &vect);
    //void powerLawIndex(HepRandomEngine *engine, const std::vector<int> &histpl, const double factor, std::vector<double> &vect);
    
    
    
    // data members
    std::vector<double>   m_duration;
    std::vector<double>   m_flux;
    std::vector<double>   m_fraction;
    std::vector<double>   m_alpha;
    std::vector<double>   m_beta;
    std::vector<double>   m_epeak;
    
    
    // used to fill a vector with the product of its values with m_value
    struct calcEpeak : public std::unary_function<double, double>
    {
        calcEpeak(HepRandomEngine *engine) : m_engine(engine) {}
        double operator() (double x); 
        
        HepRandomEngine *m_engine;
    };
};



#endif // GRB_GLOBAL_DATA_H
