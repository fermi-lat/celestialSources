// FILE: GRB.cxx

// This class is instantiated in two ways:
// -  Input: Filename
//		 In this mode, it will read the photon list (time,energy) generated by the first option if filename is not empty,
//			Otherwise, it creates "n" bursts
// -  Input: duration, flux, fraction, power law index, npulse, flag
//		 In this mode, it creates a photon list for the burst specified by the input parameters and if the flag is set,
//			records it in a file
//

#include <fstream>
#include <algorithm>              // for transform
#include <numeric>                // for accumulate

#include "GRB.h"
#include "GRBpulse.h"
#include "GrbGlobalData.h"
#include "GRBobsConstants.h"
#include "GRBsimvecCreator.h"
#include "CLHEP/Random/RandFlat.h"
#include "facilities/Util.h"


using namespace grbobstypes;



// Constructor  GRB()
// Initializes member data
//
// Input:
//
// Output:
//		GRB object
//
// Calls:

GRB::GRB()
    :m_grbdir(std::make_pair<float,float>(0.0,0.0)),
     m_univFWHM(0.0),
     m_specnorm(),
     m_nphoton(0),
     m_photonlist(),
     m_globalData(new GlobalData)
{
}



// Constructor  GRB(const std::vector<std::string> &paramVector)
// Initializes member data and reads GRB from specified file in paramVector
//
// Input:
//      paramVector				: specifies directory name (optional) and filename containing GRB data
//
// Output:
//		GRB object
//
// Calls:

GRB::GRB(const std::vector<std::string> &paramVector)
    :m_grbdir(std::make_pair<float,float>(0.0,0.0)),
     m_univFWHM(0.0),
     m_specnorm(),
     m_nphoton(0),
     m_photonlist(),
     m_globalData(new GlobalData)
{
    readGRB(paramVector);
}



GRB::GRB(HepRandomEngine *engine, const std::string &prefix, const double duration, const int npuls, const double flux,
         const double fraction, const double alpha, const double beta, const double epeak, const double specnorm,
         const bool flag)
         :m_grbdir(std::make_pair<float,float>(0.0,0.0)),
          m_univFWHM(0.0),
          m_specnorm(),
          m_nphoton(0),
          m_photonlist(),
          m_globalData(new GlobalData)
{
    createGRB(engine, prefix, duration, npuls, flux, fraction, alpha, beta, epeak, specnorm, flag);
}



// Copy Constructor
// Initializes member data and reads GRB from specified file in paramVector
//
// Input:
//      right				: GRB object to be copied
//
// Output:
//		copy of the input GRB object
//
// Calls:
//      GlobalData::clone 
GRB::GRB(const GRB &right)
    :m_grbdir(right.m_grbdir),
     m_univFWHM(right.m_univFWHM),  
     m_specnorm(right.m_specnorm),
     m_nphoton(right.m_nphoton),
     m_photonlist(right.m_photonlist)
{
    if (right.m_globalData)
        m_globalData = right.m_globalData->clone();
}



// Destructor
GRB::~GRB()
{
    delete m_globalData;
    m_globalData = 0;
}



// Helper function for the assignment operator
void GRB::swap(GRB &other) throw()
{
    std::swap(m_grbdir, other.m_grbdir);
    std::swap(m_univFWHM, other.m_univFWHM);
    std::swap(m_specnorm, other.m_specnorm);
    std::swap(m_nphoton, other.m_nphoton);
    std::swap(m_photonlist, other.m_photonlist);
    std::swap(m_globalData, other.m_globalData);
}



// Assignment Operator
GRB &GRB::operator=(const GRB &right)
{
    GRB temp(right);   // does all the work
    swap(temp);   // this can't throw
    return *this;
}


// createGRB(HepRandomEngine *engine, const std::string &prefix, const std::string &dir)
//		GRB Simulation Overview:
//		(1) GRB calls GRBglobal, which calls procedures that return Nbsim samples from each of the burst
//			integral distributions { durations, peak fluxes, power-law indices }.
//		(2) Module makeGRB computes the number of photons for this burst.
//		(3) Module maketimes makes BATSE-like time profiles, but with pulse widths extrapolated to
//			GLAST energies, generated in a call to module pickwidth; photons are distributed within a 
//			given pulse according to an energy-dependent formulation.
//
//		Generates "nbsim" number of bursts.  Loops through each burst, creates a photon list (time,energy) 
//      and records the list in an output file.
//
// Input:
//		engine						:	pointer to a HepRandomEngine object
//      prefix                      :   type of GRB (LAT/GBM)
//      dir                         :   directory name containing burst file
//		flux						:	peak flux
//      fraction                    :   fraction
//		duration					:	burst duration 
//		alpha						:   broken power law index
//		beta						:	broken power law index
//      epeak                       :   
//		grbcst::nbsim				:	long
//		m_specnorm					:	spectral normalization 
//
// Output:
//		m_nphoton					:	number of photons generated by the current burst
//		GRB object
//
// Calls:
//      GrbGlobalData::Instance
//      GlobalData::setDuration
//      GlobalData::setFlux
//      GlobalData::setFraction 
//      GlobalData::setAlpha
//      GlobalData::setBeta	
//      GlobalData::setEpeak
//      GlobalData::setNpuls
//      GlobalData::setSpecnorm	
//		baseFilename
//      calcNphoton
//		direction
//		makeGRB	
//		operator<<	
//		outputFilename


GRB::createGRB(HepRandomEngine *engine, const std::string &prefix, const std::string &dir)
{
    // Choose from the distributions for durations, peak fluxes, and spectral power-law indices
    std::vector<double> duration      = GrbGlobalData::instance(engine)->duration();	
    std::vector<double> flux          = GrbGlobalData::instance(engine)->flux();	
    std::vector<double> fraction      = GrbGlobalData::instance(engine)->fraction();	
    std::vector<double> alpha		  = GrbGlobalData::instance(engine)->alpha();	
    std::vector<double> beta		  = GrbGlobalData::instance(engine)->beta();	
    std::vector<double> epeak		  = GrbGlobalData::instance(engine)->epeak();	
    
    // create base name for the output files to be generated
    std::string base = baseFilename(prefix, dir);
    
    
    // For each burst, create its attributes
    for (long isim=0; isim<grbcst::nbsim; ++isim)
    {
        std::cout << "Processing " << prefix << " Burst: " << isim << std::endl;
        std::cout << "dur: " << duration[isim] << " alpha: " << alpha[isim] << " beta: " << beta[isim] <<
            " epeak: " << epeak[isim] << std::endl;
        
        m_globalData->setDuration(duration[isim]);
        m_globalData->setFlux(flux[isim]);
        m_globalData->setFraction(fraction[isim]);
        m_globalData->setAlpha(alpha[isim]);
        m_globalData->setBeta(beta[isim]);
        m_globalData->setEpeak(epeak[isim]);
        m_globalData->setNpuls(0);
        
        std::cout << "call calcNphoton\n";
        if ((m_nphoton=calcNphoton(engine)) > 5)
        {
            m_globalData->setSpecnorm(m_specnorm[isim]);
            m_grbdir = direction(engine);
            
            makeGRB(engine);
            
            std::string fname = outputFilename(base, isim);
            std::ofstream os(fname.c_str());
            os << *this;
        }
        
        else
        {
            std::cout << "no GRB made: Insufficient flux;" << std::endl;
            std::cout << "nphoton: " << m_nphoton << std::endl << std::endl;
        }
    }
    
    //	GrbGlobalData::kill();
}




// createGRB(HepRandomEngine *engine, const std::string &prefix, const double duration, const int npuls, const double flux,
//			   const double fraction, const double alpha, const double beta, const double epeak, const double specnorm,
//			   const bool flag)
// Creates the photon list (time,energy) for the burst specified by the input parameters 
//		and records it in a file if the flag is set.
//
// Input:
//		engine						:	pointer to a HepRandomEngine object
//      prefix                      :   type of GRB (LAT/GBM)
//		duration					:	burst duration 
//      npuls                       :   number of pulses in current burst
//		flux						:	peak flux
//      fraction                    :   fraction
//		alpha						:   broken power law index
//		beta						:	broken power law index
//      epeak                       :   
//		specnorm					:	spectral normalization 
//      flag                        :   true : write GRB data to a file
//		grbcst::nbsim				:	long
//
// Output:
//		GRB object
//
// Calls:
//      GlobalData::setDuration
//      GlobalData::setFlux	
//      GlobalData::setFraction
//      GlobalData::setAlpha
//      GlobalData::setBeta	
//      GlobalData::setEpeak
//      GlobalData::setNpuls
//      GlobalData::setSpecnorm	
//      calcNphoton 
//		direction
//		makeGRB	
//		operator<<	

GRB::createGRB(HepRandomEngine *engine, const std::string &prefix, const double duration, const int npuls, const double flux,
               const double fraction, const double alpha, const double beta, const double epeak, const double specnorm,
               const bool flag)
{
    m_globalData->setDuration(duration);
    m_globalData->setFlux(flux);
    m_globalData->setFraction(fraction);
    m_globalData->setAlpha(alpha);
    m_globalData->setBeta(beta);
    m_globalData->setEpeak(epeak);
    m_globalData->setSpecnorm(specnorm);
    m_globalData->setNpuls(npuls);
    
    if ((m_nphoton=calcNphoton(engine)) > 5)
    {
        m_grbdir = direction(engine);
        
        std::cout << "Creating photon list..." << std::endl;
        makeGRB(engine);
        
        if (flag)
        {
            std::string out("GRB_c3.lis");
            std::ofstream os(out.c_str());
            os << *this;
        }
    }
    
    else 
    {
        std::cout << "no GRB made: Insufficient flux;" << std::endl;
        std::cout << "nphoton: " << m_nphoton << std::endl;
    }
}




// readGRB(const std::vector<std::string> &paramVector)
// Reads the photon list (time,energy) generated by an instantiation of GRB().
//
// Input:
//		paramVector						:	directory and filename containing GRB data
//
// Output:
//		GRB object
//
// Calls:
//      facitliies::Util::expandEnvVar 
//		operator>>
//
// Caller:
//      constructor

GRB::readGRB(const std::vector<std::string> &paramVector)
{
    try
    {
        std::string location = paramVector[0];
        std::cout << "location: " << location << std::endl;
        facilities::Util::expandEnvVar(&location);
        
        std::string fname = location + paramVector[1];
        
        std::cout << "Reading photon list from " << fname << "..." << std::endl;
        std::ifstream is (fname.c_str());
        is >> *this;
        
        std::cout << "m_flux: " << m_globalData->flux() << std::endl;
        std::ofstream os("GRB_c2.lis");
        os << *this;
    }
    
    catch (...)
    {
        std::cout << "Error while opening input file: " << paramVector[1] << std::endl;
    }
}




// clone()
// Makes a copy of itself and returns it to the caller.
//
// Input:
//		this						:	pointer to the GRB object to be duplicated
//
// Output:
//		GRB object					:	pointer to the newly created copy of the object pointed to by the "this" pointer
//
// Calls:
//		GRB(const GRB &)
//
// Caller:
//     interface to the simulation

GRB *GRB::clone() const
{
    return new GRB(*this);
}



// Default constructor  baseFilename(const std::string &prefix, const std::string &dir)
// Returns a string containing base name used for the generation of output file name.
//
// Input:
//      prefix                      :   type of GRB (LAT/GBM)
//      dir                         :   directory name containing burst file
//		grbcst::nbsim				:	long
//
// Output:
//		base						:	string used to generate the output file name
//
// Calls:
//      expandEnvVar
//
// Caller:
//		createGRB

std::string GRB::baseFilename(const std::string &prefix, const std::string &dir) const
{
    char *ind = new char(80);
    
    std::string base;
    
    if (dir.size() > 1)    // null terminated - so the size is at least "1"
    {
        std::string location = dir;
        facilities::Util::expandEnvVar(&location);
        base = location + prefix + "_GRB_";
    }
    
    else
        base = prefix + "_GRB_";
    
    sprintf(ind, "%ld", grbcst::nbsim);
    int i = strlen(ind);
    
    for (int j=0; j<i; ++j)
        base += '0';
    
    return base;
}




// Default constructor  outputFilename()
// Uses base string generated by baseFilename to create name of the output file.
//
// Input:
//		base						:	base name
//		isim						:	index for the newly generated burst
//
// Output:
//		fname						:	name of the output file
//
// Calls:
//		--
//
// Caller:
//		GRB()

std::string GRB::outputFilename(const std::string &base, const long isim) const
{
    static std::string::size_type baseSize = base.size();
    
    std::string fname = base;
    
    char *ind = new char(80);
    sprintf(ind, "%ld", isim);
    
    fname.replace(baseSize-strlen(ind), baseSize-1, ind);
    fname += ".lis";
    
    return fname;
}




// direction(engine)
// Calculates the direction of the burst.
//
// Input:
//		engine							:	pointer to a HepRandomEngine object
//
// Output:
//		direction <zenith,azimuth> pair	:	direction of tbe current burst
//
// Calls:
//		engine->flat
//
// Caller:
//		constructors

//		Assume isotropic GRB position distribution on sky, and select from
//		zenith acceptance angle (w.r.t. instrument axis), 0 => 75 degrees 
//		(zenNorm = cos[75 degrees]).

std::pair<float,float> GRB::direction(HepRandomEngine *engine) const
{
    float coszenith = 1.0 - engine->flat() * grbcst::zenNorm;
    float azimuth    = 2. * M_PI * engine->flat();
    
    return std::make_pair<float,float> (-coszenith, azimuth);
}




// getTimes(HepRandomEngine *engine, const double ethres, const long nphots, const long deltbinsleft, const long iphotoff, 
//				   const double tmax, const std::vector<double> &pulse)
// Uses pulse data to generate list of photon times
//
// Input:
//		engine								:	pointer to a HepRandomEngine object
//		ethres								:	double
//		nphots								:	number of photons in the current pulse
//		deltbinsleft						:	value generated by GRBpulse::createSigmaTdiff method
//		iphotoff							:	index to the first photon to generate time for
//		tmax								:	time for peak amplitude for the current burst and pulse
//		pulse								:	vector generated by GRBpulse::getPulse method
//		grbcst::timres						:	double
//
// Output:
//		times								:	"nphots" photon times for the elements in range [iphotoff,iphotoff+nphots)
//
// Calls:
//		GRBobsUtilities::cumulativeSum
//		GRBobsUtilities::multiplier
//		engine->flat
//
// Caller:
//		makeTimes
//		

void GRB::getTimes(HepRandomEngine *engine, const double ethres, const long nphots, const long deltbinsleft, const long iphotoff, 
                   const double tmax, const std::vector<double> &pulse)
{
    std::vector<double> cumpulse;
    
    GRBobsUtilities::cumulativeSum(pulse, cumpulse);
    double maxval = cumpulse[cumpulse.size()-1];
    std::transform(cumpulse.begin(), cumpulse.end(), cumpulse.begin(), GRBobsUtilities::multiplier(1./maxval));
    
    double photontime, efactor, twidthscale;
    
    for (int iphot=0; iphot<nphots; ++iphot)
    {
        DoubleIter it = cumpulse.end();
        while (it == cumpulse.end())
            it = std::find_if(cumpulse.begin(), cumpulse.end(), std::bind2nd(std::greater_equal<double>(), engine->flat()));
        
        int index = std::distance(cumpulse.begin(), it);
        
        photontime   = (index - deltbinsleft) * grbcst::timres;
        efactor      = pow((m_photonlist[iphot+iphotoff].energy() / ethres), -0.333);
        
        twidthscale  = photontime * efactor;
        
        m_photonlist[iphot+iphotoff].setTime(twidthscale + tmax + 0.5 * efactor * deltbinsleft * grbcst::timres);
    }
}




// makeTimes(HepRandomEngine *engine, const double ethres)
//		Makes BATSE-like GRB time profiles, placing GLAST photons a la cumulative BATSE intensity, 
//		but in narrower pulses:
//		(1) m_npuls = number of pulses, proportional to BATSE duration.
//		(2) pulse peak amplitude is random (0.0=>1.0); sort amps in descending amp order.
//		(3)	scramble amps of {1st,2nd} halves of pulses, separately (leaves profile assymmetric).
//		(4)	center of pulse time is random within duration.  sort the times in ascending order.
//		(5)	pulse width is drawn from BATSE width distribution for bright bursts (attributes paper), 
//			scaled to GLAST energies using width ~E^-0.333.
//		(6)	make m_npuls pulses with "bisigma" shapes => sum to produce time profile
//		(7)	form cumulative distribution of BATSE-like intensity
//		(8) distribute the m_nphoton photons according to cumulative intensity => GRBtimes
//		(9)	offset the photon times according to
//			(a) energy dependence, width ~E^-0.333 and
//			(b) time of peak, also proportional to E^-0.333.
//
// Input:
//		engine						:	pointer to a HepRandomEngine object
//		ethres						:	threshold value
//
// Output:
//		m_npuls						:	number of pulses
//		times						:	photon times sorted in ascending order
//
// Calls:
//      GlobalData::npuls 
//      GlobalData::setNpuls 
//      GlobalData::duration
//		GRBpulse::data
//		getTimes
//
// Caller:
//		makeGRB

void GRB::makeTimes(HepRandomEngine *engine, const double ethres)
{
    if (m_globalData->npuls() == 0)
        m_globalData->setNpuls(std::max(int(15 * m_globalData->duration()/30 + 0.5), 1));
    
    try
    {
        GRBpulse *grbPulse = new GRBpulse;
        int npuls = m_globalData->npuls();
        
        long deltbinsleft = grbPulse->data(engine, ethres, m_nphoton, npuls, m_globalData->duration());
        
        // create times for each pulse
        const std::vector<double> tmax                 = grbPulse->tmax();
        const std::vector< std::vector<double> > pulse = grbPulse->pulse();
        const std::vector<long> nphotpul               = grbPulse->nphotpul();
        
        long iphotoff = 0;
        for (long ipuls=0; ipuls<npuls; ++ipuls)
        {
            if (nphotpul[ipuls] > 0)
            {
                getTimes(engine, ethres, nphotpul[ipuls], deltbinsleft, iphotoff, tmax[ipuls], pulse[ipuls]);
                iphotoff += nphotpul[ipuls];
            }
        }
        
        m_univFWHM = grbPulse->univFWHM();
        
        delete grbPulse;
    }
    
    catch(...)
    {
        std::cout << "Cannot allocate memory for the GRB pulse..." << std::endl;
    }
}




// operator>>(is, grb)
// Reads burst information and photon list (time,energy) from the input stream and updates the object grb with it
//
// Input:
//		is								:	input stream
//
// Output:
//		is								:	input stream
//		grb								:	GRB object containing following information:
//			m_nphoton					:	number of photons generated by the current burst
//			m_flux						:	peak flux
//			m_duration					:	burst duration 
//			m_alpha						:   broken power law index
//			m_beta						:	broken power law index
//			m_specnorm					:	spectral normalization 
//			m_npuls						:	number of pulses in the current burst
//			m_photonlist				:	(time, energy) pair
//
// Calls:
//		---
//
// Caller:
//		constructor GRB(filename)

std::ifstream &operator>>(std::ifstream &is, GRB &grb)
{
    std::string str;
    is >> str >> str >> str >> str >> str >> str;
    
    double duration, flux, beta, specnorm;
    int    npuls;
    
    is >> flux >> duration >> beta >> specnorm >> npuls >> grb.m_univFWHM;
    grb.m_globalData->setFlux(flux);
    grb.m_globalData->setDuration(duration);
    grb.m_globalData->setBeta(beta);
    grb.m_globalData->setNpuls(npuls);
    grb.m_globalData->setSpecnorm(specnorm);
    //is >> grb.m_globalData->m_flux >> grb.m_globalData->m_duration >> grb.m_globalData->m_beta >> 
    //	grb.m_specnorm >> grb.m_globalData->m_npuls >> grb.m_globalData->m_univFWHM;
    is >> str >> str >> str;
    
    float zenith, azimuth;
    is >> zenith >> azimuth;
    grb.m_grbdir = std::make_pair<float,float> (zenith, azimuth);
    
    is >> str >> str;
    is >> grb.m_nphoton;
    is >> str >> str >> str >> str;
    
    grb.m_photonlist.resize(grb.m_nphoton);
    
    double t, e;
    for (long i=0; i<grb.m_nphoton; ++i)
    {
        is >> t >> e;
        
        grb.m_photonlist[i].setTime(t);
        grb.m_photonlist[i].setEnergy(e);
    }
    
    return is;
}




// operator>>(os, grb)
// Writes burst information and photon list (time,energy) contained in the object grb to the output stream
//
// Input:
//		is								:	input stream
//		grb								:	GRB object containing following information:
//			m_nphoton					:	number of photons generated by the current burst
//			m_flux						:	peak flux
//			m_duration					:	burst duration 
//			m_alpha						:	broken power law index
//			m_beta						:	broken power law index
//			m_specnorm					:	spectral normalization 
//			m_npuls						:	number of pulses in the current burst
//			m_photonlist				:   (time, energy) pair
//
// Output:
//		is							:	input stream
//
// Calls:
//		---
//
// Caller:
//		default constructor GRB()

std::ofstream &operator<<(std::ofstream &os, const GRB &grb)
{
    std::pair<double,double> grbdir = grb.dir();
    
    GlobalData *globalData = grb.globalData();
    
    os << "Fp, dur, beta, Specnorm, Npulses, UnivFWHM= " << std::setw(12) << std::setiosflags(std::ios::fixed) << 
        globalData->flux() << "   " <<
        globalData->duration() << "   " << globalData->beta() << "   " << globalData->specnorm() << "   " << 
        globalData->npuls() << "  " << grb.univFWHM() << std::endl;
    
    os << "ZenAng, AziAng = " << std::setw(12) << std::setiosflags(std::ios::fixed) << grbdir.first << "   " << grbdir.second << std::endl;
    
    os << "nphotons = " << grb.nphoton() << std::endl;
    
    os << "(Times, Energies) per photon:" << std::endl;
    
    
    if (grb.nphoton() > 0)
    {
        std::vector<TimeEnergy> photonlist = grb.photonlist();
        for (long i=0; i<grb.nphoton(); ++i)
            os << std::setw(12) << std::setiosflags(std::ios::fixed) << photonlist[i].time() << "   " << photonlist[i].energy() << std::endl;
    }
    
    return os;
}